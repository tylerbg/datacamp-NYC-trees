---
title: "How to Improve NYC's Tree Population"
author: "Tyler Garner"
date: "2022-12-20"
knit: (function(input_file, encoding) {
  rmarkdown::render(input_file,
    encoding=encoding,
    output_file='../results/NYC-tree-analysis.html') })
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      fig.path = "../results/figures/")

setwd("~/R/workspace/projects/datacamp-NYC-trees/src")
```

# Analysis Plan



## Data

For this analysis we are given two data sets, the first with street tree census data and the second with neighborhood geographical information.  The observations in both data sets are within the Manhattan, NYC area.

### Tree census variables

- "tree_id" - Unique id of each tree.
- "tree_dbh" - The diameter of the tree in inches measured at 54 inches above the ground.
- "curb_loc" - Location of the tree bed in relation to the curb. Either along the curb (OnCurb) or offset from the curb (OffsetFromCurb).
- "spc_common" - Common name for the species.
- "status" - Indicates whether the tree is alive or standing dead.
- "health" - Indication of the tree's health (Good, Fair, and Poor).
- "root_stone" - Indicates the presence of a root problem caused by paving stones in the tree bed.
- "root_grate" - Indicates the presence of a root problem caused by metal grates in the tree bed.
- "root_other" - Indicates the presence of other root problems.
- "trunk_wire" - Indicates the presence of a trunk problem caused by wires or rope wrapped around the trunk.
- "trnk_light" - Indicates the presence of a trunk problem caused by lighting installed on the tree.
- "trnk_other" - Indicates the presence of other trunk problems.
- "brch_light" - Indicates the presence of a branch problem caused by lights or wires in the branches.
- "brch_shoe" - Indicates the presence of a branch problem caused by shoes in the branches.
- "brch_other" - Indicates the presence of other branch problems.
- "postcode" - Five-digit zip code where the tree is located.
- "nta" - Neighborhood Tabulation Area (NTA) code from the 2010 US Census for the tree.
- "nta_name" - Neighborhood name.
- "latitude" - Latitude of the tree, in decimal degrees.
- "longitude" - Longitude of the tree, in decimal degrees.

### Neighborhood variables

- "ntacode" - NTA code (matches Tree Census information).
- "ntaname" - Neighborhood name (matches Tree Census information).
- "geometry" - Polygon that defines the neighborhood.

## Questions and goals

[1. What are the most common tree species in Manhattan?](#most-common-tree-species-in-manhattan)

This question will be approached in two ways.  First, we will get a count of the total number of trees for each unique value for the species name variable.  Then, we will similarly get a second count but after extracting the text from the species name variable to get more generalized groupings of tree species.  Both will be plotted side-by-side to answer this question.

[2. Which are the neighborhoods with the most trees?](#neighborhoods-with-the-most-trees)

This question will similarly be approached in two ways.  First by counting the total of trees within each neighborhood, then by determining the density of trees in each neighborhood by diving the total number of trees by the geographical area.  Both will be plotted side-by-side to answer this question.

[3. A visualization of Manhattan's neighborhoods and tree locations.](#visualizing-manhattan-neighborhoods-and-tree-locations)

To visualize Manhattan's neighborhoods and their trees in one plot, we will plot each tree on a map of Manhattan and use colors to differentiate which trees belong to which neighborhood.  Then, we will draw an outline of the neighborhoods to better define their borders.  A legend will be used to identify which colors represent each neighborhood.

[4. What ten tree species would you recommend the city plant in the future?](#recommendations-for-future-tree-planting)

To answer this question, we will quantify the proportion of trees in good health for each species.  Additionally, we will gather the median, 75th quantile, and maximum diameters, each of which are measurements of the higher 50% of trees and for which we will assume each represent typical sizes of adult trees.  With these numbers, we will employ a weighted ranking approach to arrange the tree species by those who have the highest proportion of trees in good health and have a larger size.  Additionally, we will filter out species identified by the United States Geological Survey as being invasive species.  Finally, we will qualitatively research the top tree species until 10 ideal species are selected.



# EDA

For this analysis we will use the following libraries:

- `sf` - tools for geospatial analysis and visualization.
- `tidytext` - tools for text analysis.
- `pals` - provides additional and larger color palettes for visualizations.
- `units` - for calculating and displaying units in plots.
- `tidyverse` - suite of tools for data manipulation and visualization.

We will first load in these libraries and then the tree census data set.

```{r load, results = 'hide'}
libs <- c('sf', 'tidytext', 'pals', 'units', 'htmlTable', 'gridExtra', 'tidyverse')

sapply(libs, library, character.only = TRUE)

trees <- read_csv('../data/raw/trees.csv')
```

We will then get some information about the data set, including its dimensions, structure, and some descriptive statistics of the variables.

```{r data-info}
dim(trees)
str(trees)
summary(trees)
```



There are no apparent missing values.

For the `character` variables, we will determine how many unique values are in each variable to assess whether we want to keep them as `character` or convert them to the `factor` type.

```{r unique-chars}
trees %>%
  select(where(is_character)) %>%
  apply(2, function(x) length(unique(x)))
```

The number of unique values for each of the `character` columns ranges between 2 and 129, with most variables at or near 2.  Since we have a large amount of observations (over 60,000), we can assign each as factors.  We will then print new summary statistics for the data set.

```{r char-to-factor}
trees <- trees %>%
  mutate(across(where(is_character), factor))

summary(trees)
```

In the output, there are now obvious missing values, specifically in the *spc_common* and *health* columns.  The total number of missing values in both variables is about the same, so we will check how many observations are missing values for both variables.  Also to note, the number of missing values also matches the 'Dead' value for the *status* variable, for which we will also check how many missing values belong.

```{r obs-na}
sum(is.na(trees$spc_common) & is.na(trees$health))

sum(is.na(trees$health) & trees$status == 'Dead')
```

All observations except one with missing values in the *health* variable shares a missing value in the *spc_common* variable.  Additionally, all of the missing values in the *health* variable come from observations where *health* has a value of 'Dead'.  Therefore, instead of dropping missing values we will recode the missing values in *spc_common* as 'Unknown' and those in *health* as 'Dead'.

```{r na-recode}
trees <- trees %>%
  mutate(spc_common = fct_explicit_na(spc_common, 'Unknown'),
         health = fct_explicit_na(health, 'Dead'))
```


### Number of each species

```{r}
trees %>%
  count(spc_common) %>%
  ggplot(aes(x = n)) +
    geom_histogram(bins = 100) +
    geom_rug()
```

From the distribution of species we can see that most of the species are uncommon around Manhattan, while a small subset of trees are quite common and apparently make up the majority of all trees.

```{r}
trees %>% count(spc_common) %>% filter(n > 2500) %>% select(n) %>% sum() / nrow(trees)
```


### Tree trunk sizes

```{r trunk-sizes}
trees %>%
  filter(status == 'Alive') %>%
    ggplot(aes(x = tree_dbh)) +
    geom_histogram(bins = 100) +
    geom_rug()

sum(trees$tree_dbh == 0)
```

The distribution of trunk diameters is right-skewed with some extreme values.  The right-skewness might be expected when measuring the size of plants that generally have grown for a long period of time.  However, the extreme values might not be expected and could be the result of entry error.

There are 43 tree diameter measures that are 0.  This could be a results of data entry error or that the tree was not over 54 inches to measure the diameter.

For the right-skew and extreme points, we will aim to keep the tailing while removing likely outliers.  It appears at around 50 inches the tailing ends and the more extreme points begin, so we will use that as a cut-off point and replace the values above that threshold with their respective species median diamater.

```{r outliers-median}
# Get the median diameter for each tree species
diam_med <- trees %>%
  group_by(spc_common) %>%
  summarize(median = median(tree_dbh))

# Replace outliers with their respecitve species median diamater
trees <- trees %>%
  mutate(tree_dbh = ifelse(tree_dbh > 50,
                           diam_med$median[which(diam_med$spc_common %in% spc_common)],
                           tree_dbh))
trees %>%
  filter(status == 'Alive') %>%
    ggplot(aes(x = tree_dbh)) +
    geom_histogram(bins = 50) +
    geom_rug()
```




### Tree problems

```{r}
# Create new variables to indicate whether there are any root, trunk, or branch problems at all

trees <- trees %>%
  mutate(root_any = ifelse(root_stone == 'Yes' | root_grate == 'Yes' | root_other == 'Yes', 'Yes', 'No'),
         trnk_any = ifelse(trunk_wire == 'Yes' | trnk_light == 'Yes' | trnk_other == 'Yes', 'Yes', 'No'),
         brch_any = ifelse(brch_shoe == 'Yes' | brch_light == 'Yes' | brch_other == 'Yes', 'Yes', 'No'))

trees %>%
  select(nta_name, root_stone:brch_other, root_any:brch_any) %>%
  pivot_longer(!nta_name) %>%
  group_by(nta_name, name) %>%
  summarize(yes = sum(value == 'Yes') / n(),
            no = sum(value == 'No') / n()) %>%
  pivot_longer(c(yes, no), names_to = 'yes_no') %>%
  ggplot(aes(x = yes_no, y = value)) +
    geom_col() +
    facet_wrap(~ name)
```


# Analysis

## Most common tree species in Manhattan

We should also look at how many times each tree name pops up.  For instance, the word 'pine' is a part of many species, such as 'black pine', 'Virginia pine', and 'white pine'.

We will check for any dupilcated lines, which would mean the same word appears twice for a tree and may be an entry error (for example, 'pine red pine').  Then, we will print a list of the top 10 words that are in the species variable.

```{r common-species-plots}
species_10 <- trees %>%
  group_by(spc_common) %>%
  count(name = 'total_trees') %>%
  arrange(desc(total_trees)) %>%
  head(n = 10) %>%
  ungroup()

sp1 <- species_10 %>%
  mutate(spc_common = fct_reorder(spc_common, desc(total_trees))) %>%
  ggplot(aes(x = spc_common,
             y = total_trees)) +
  geom_col() +
    geom_col(fill = 'chartreuse4',
             color = 'grey40') +
    scale_x_discrete(labels = function(x) str_wrap(x,
                                                   width = 20,
                                                   whitespace_only = FALSE)) +
    labs(x = 'Species',
         y = 'Total number of trees',
         title = 'Top 10 most abundant tree species\nin Manhattan') +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 30,
                                     vjust = 1,
                                     hjust = 1))

spc_tokens <- trees %>%
  select(tree_id, spc_common) %>%
  mutate(spc_common = as.character(spc_common)) %>%
  unnest_tokens(word, spc_common)

sum(duplicated(spc_tokens))

scp_top <- spc_tokens %>%
  group_by(word) %>%
  summarize(n = n()) %>%
  arrange(desc(n)) %>%
  head(n = 10)

sp2 <- scp_top %>%
  mutate(word = fct_reorder(word, desc(n))) %>%
  ggplot(aes(x = word,
           y = n)) +
  geom_col() +
    geom_col(fill = 'chocolate3',
             color = 'grey40') +
    scale_x_discrete(labels = function(x) str_wrap(x,
                                                   width = 20,
                                                   whitespace_only = FALSE)) +
    labs(x = 'Word',
         y = 'Total number of trees',
         title = 'Top 10 most abundant species-associated words\nin Manhattan') +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 30,
                                     vjust = 1,
                                     hjust = 1))

grid.arrange(sp1, sp2, nrow = 1)
```

Comparing this list with the results above we can conclude:

- 'honeylocust' is the most common tree species in Manhattan.
- 'oak' is the second most common species, with 'pin oak' being the most abundant type of oak tree.
- 'Callery pear' is the third most common species and is the only type of pear tree.
- The next most common tree species are 'ginkgo', 'linden' with 'littleleaf linden' as the most prominent, 'Sophora', and 'London planetree'.


## Neighborhoods with the most trees


The spatial data set provided in the Data Camp assignment does not load properly in R, either locally or in the Data Camp workspace.  Therefore, we will load the raw data directly from NYC Open Data, then filter the spatial data set for only the Manhattan area.

```{r}
neighborhoods <- st_read('../data/raw/direct_NYC/geo_export_be6f9d73-0dae-46ea-bbed-99ae04ed44e2.shp', quiet=TRUE)

manhattan <- neighborhoods %>%
  filter(boroname == 'Manhattan')
```

First, we will determine which neighborhoods have the most total number of trees.  Next we will calculate the area of each neighborhood, then calculate the number of trees per square meter.

```{r}
# Create a ggplot object for the top 10 neighborhoods with the most trees
top_total <- trees %>%
  group_by(nta_name) %>%
  summarize(total_trees = n()) %>%
  arrange(desc(total_trees)) %>%
  head(n = 5)
  
p1 <- top_total %>%
  mutate(nta_name = fct_reorder(nta_name,
                                desc(total_trees))) %>%
    ggplot(aes(x = nta_name,
             y = total_trees)) +
    geom_col(fill = 'steelblue2',
             color = 'grey40') +
    scale_x_discrete(labels = function(x) str_wrap(x,
                                                   width = 20,
                                                   whitespace_only = FALSE)) +
    labs(x = 'Neighborhood',
         y = 'Total number of trees',
         title = 'Top 10 neighborhoods with the most\ntrees in Manhattan') +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 30,
                                     vjust = 1,
                                     hjust = 1))

# Calculate neighborhood areas then create ggplot object for the top 10 neighborhoods with the
# most trees per square meter
manhattan$sq_m <-st_area(manhattan$geometry)

top_density <- left_join(trees %>% select(nta, nta_name),
          manhattan %>% select(ntacode, sq_m),
          by = c('nta' = 'ntacode')) %>%
  group_by(nta_name) %>%
  summarise(tree_by_area = n() / max(sq_m)) %>%
  arrange(desc(tree_by_area)) %>%
  head(n = 5)

p2 <- top_density %>%
  mutate(nta_name = fct_reorder(nta_name,
                                desc(tree_by_area))) %>%
  ggplot(aes(x = nta_name,
             y = tree_by_area)) +
    geom_col(fill = 'goldenrod2',
             color = 'grey40') +
    scale_x_discrete(labels = function(x) str_wrap(x,
                                                   width = 20,
                                                   whitespace_only = FALSE)) +
    labs(x = 'Neighborhood',
         y = 'Tree density',
         title = 'Top 10 neighborhoods with the highest\ntree density in Manhattan') +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 30,
                                     vjust = 1,
                                     hjust = 1))

# Plot both graphs side-by-side
grid.arrange(p1, p2, nrow = 1)
```

The Upper West Side has the highest total number of trees for all of the neighborhoods in Manhattan.  Conversely, The Upper East Side-Carnegie Hill has the highest density of trees.




## Visualizing Manhattan's neighborhoods and tree locations.

Then, we will plot the tree locations with the NTA neighborhood borders using a distinct color for the trees that reside in each neighborhood.

```{r nta-tree-map}
ggplot(manhattan) + 
  geom_point(data = trees,
             aes(longitude, latitude, color = nta_name),
             size = 0.1, alpha = 0.05) +
  geom_sf(fill = NA) +
  scale_color_manual(name = 'Neighborhood',
                     values = as.vector(polychrome())) +
  labs(x = NULL,
       y = NULL) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 30, vjust = 1, hjust = 1)) +
  guides(color = guide_legend(override.aes = list(pch = 15, size = 4, alpha = 1)))
```

## Recommendations for future tree planting


```{r}
trees_health_diam <- trees %>%
  group_by(spc_common) %>%
  summarize(perc_good = sum(health == 'Good') / n() * 100,
            perc_fair = sum(health == 'Fair') / n() * 100,
            perc_poor = sum(health == 'Poor') / n() * 100,
            perc_good_fair = perc_good + perc_fair,
            median_diam = median(tree_dbh),
            diam_75 = as.numeric(quantile(tree_dbh, 0.75)),
            max_diam = max(tree_dbh),
            total = n()) %>%
  filter(total >= 50) %>%
  arrange(desc(perc_good))

head(trees_health_diam)

head(trees_health_diam,
     n = 20) %>%
  mutate(across(perc_good:perc_good_fair, ~ round(.x, 1))) %>%
  htmlTable(header = c('Species', '% Good', '% Fair', '% Poor', '% Good or Fair', 'Median Diameter',
                       'Max Diameter', 'Total'))

# Filter out invasive species
invasive_df <- read_csv('../data/external/USRIISv2_MasterList.csv') %>%
  select(vernacularName) %>%
  mutate(vernacularName = tolower(vernacularName))

invasive_species <- trees_health_diam %>%
  mutate(spc_common = tolower(spc_common)) %>%
  inner_join(invasive_df %>% mutate(vernacularName = tolower(vernacularName)),
             by = c('spc_common' = 'vernacularName')) %>%
  distinct()


trees_noninvasive <- trees_health_diam %>%
  filter(!tolower(spc_common) %in% invasive_species$spc_common)

# Weighted ranks-based approach
trees_noninvasive %>%
  mutate(good_rank = rank(1 / perc_good),
         poor_rank = rank(perc_poor),
         median_rank = rank(1 / median_diam),
         diam_75_rank = rank(1 / diam_75),
         max_rank = rank(1 / max_diam)) %>%
  rowwise() %>%
  mutate(avg_rank = mean(c(good_rank * 3/4, poor_rank / 4, median_rank * 3/12, diam_75_rank / 6, max_rank * 1/12))) %>%
  ungroup() %>%
  mutate(perc_good = round(perc_good, 1),
         perc_poor = round(perc_poor, 1),
         avg_rank = rank(avg_rank)) %>%
  arrange(avg_rank) %>%
  select(spc_common, perc_good, perc_poor, median_diam, diam_75, max_diam, avg_rank) %>%
  head(n = 20) %>%
  htmlTable(header = c('Species', '% Good', '% Poor', 'Median Diameter', '75th Quantile', 'Max Diameter', 'Weighted Rank'))
```

The rankings are weighted equally between tree health and tree size.  For tree health, the proportion of trees in 'good' and 'poor' health account for 75% and 25% of its weight, respectively.  For tree size, the median diameter, diameter for the 75th quantile, and maximum diameter account for 50%, 33.3% and 16.7%, or 1/2, 1/3, and 1/6, of its weight, respectively.

Of the top 20 weighted ranks, 6 species of oak and 3 species of elm are represented, indicating that oak and elm trees generally have good health and grow to a larger size in Manhattan compared to other species.  Therefore, these types of tree species generally should have preferences for future planting. 

Of the top 20 species, 6 are invasive species and should not be in consideration for future planting.  These species are:


The tree that ranked highest for having good health and a large size is the willow oak.  

The pin oak is the third ranking tree on the list. As per the [University of Kentucky Department of Horticulture](https://www.uky.edu/hort/Pin-oak), while the pin oak is easy to transplant and ideal for large landscapes, it has a high-maintenance cost due to its lowly hanging branches.

Kentucky coffeetree [UKY](https://www.uky.edu/hort/Kentucky-Coffeetree) 

The American elm had the largest median, 75th quantile, and maximum diameter in the top 20 list while also having over 80% of trees in good health.  [USDA](https://www.srs.fs.usda.gov/pubs/misc/ag_654/volume_2/ulmus/americana.htm)

[United States Register of Introduced and Invasive Species (US-RIIS) (ver. 2.0, November 2022)](https://www.sciencebase.gov/catalog/item/62d59ae5d34e87fffb2dda99?community=USGS+Science+Analytics+and+Synthesis+Foundational+Data)


[USDA NY Weeds](https://adminplants.sc.egov.usda.gov/java/invasiveOne?pubID=NEAST)